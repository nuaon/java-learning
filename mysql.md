### Mysql事务简介

数据库的事务是指一组sql语句组成的数据库逻辑处理单元，在这组的sql操作中，要么全部执行成功，要么全部执行失败。



### 事务的特性[ACID简介]

在Mysql中事务的四大特性主要包含：`原子性（Atomicity）`、`一致性（Consistent）`、`隔离性（Isalotion）`、`持久性(Durable)`，简称为ACID。
原子性是指事务的原子性操作，对数据的修改要么全部执行成功，要么全部失败，实现事务的原子性，是基于日志的`Redo/Undo机制`。
一致性是指执行事务前后的状态要一致，可以理解为数据一致性。
隔离性侧重指事务之间相互隔离，不受影响，这个与事务设置的隔离级别有密切的关系。
持久性则是指在一个事务提交后，这个事务的状态会被持久化到数据库中，也就是事务提交，对数据的新增、更新将会持久化到书库中。
原子性、隔离性、持久性都是为了保障一致性而存在的，一致性也是最终的目的。


### ACID原理

原子性是基于日志的Redo/Undo机制，你能说一说Redo/Undo机制吗？
Redo/Undo机制比较简单，它们将所有对数据的更新操作都写到日志中。

Redo log用来记录某数据块被修改后的值，可以用来恢复未写入 data file 的已成功事务更新的数据；Undo log是用来记录数据更新前的值，保证数据更新失败能够回滚。
假如数据库在执行的过程中，不小心崩了，可以通过该日志的方式，回滚之前已经执行成功的操作，实现事务的一致性。
假如某个时刻数据库崩溃，在崩溃之前有事务A和事务B在执行，事务A已经提交，而事务B还未提交。当数据库重启进行 crash-recovery 时，就会通过Redo log将已经提交事务的更改写到数据文件，而还没有提交的就通过Undo log进行roll back。



### 事务隔离级别

在Mysql中事务的隔离级别分为四大等级，`读未提交（READ UNCOMMITTED）`、`读提交 （READ COMMITTED）`、`可重复读 （REPEATABLE READ）`、`串行化 （SERIALIZABLE）`。
读未提交会读到另一个事务的未提交的数据，产生脏读问题；

读提交则解决了脏读的，出现了不可重复读，即在一个事务任意时刻读到的数据可能不一样，可能会受到其它事务对数据修改提交后的影响，一般是对于update的操作。
可重复读解决了之前不可重复读和脏读的问题，但是由带来了幻读的问题，幻读一般是针对inser操作。

`读未提交（READ UNCOMMITTED）` 事务B读取了事务A尚未提交的数据
`读提交 （READ COMMITTED）` 事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变
`可重复读 （REPEATABLE READ）`
`串行化 （SERIALIZABLE）` 串行化的执行流程相当于把事务的执行过程变为顺序执行

Serializable是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。

这四大等级从上到下，隔离的效果是逐渐增强，但是性能却是越来越差


*MySQL的默认隔离级别就是Repeatable read*


### Mysql的锁机制


在Mysql中的锁可以分为分`享锁/读锁（Shared Locks）`、`排他锁/写锁（Exclusive Locks）` 、`间隙锁`、`行锁（Record Locks）`、`表锁`

在四个隔离级别中加锁肯定是要消耗性能的，而读未提交是没有加任何锁的，所以对于它来说也就是没有隔离的效果，所以它的性能也是最好的。
对于串行化加的是一把大锁，读的时候加共享锁，不能写，写的时候，家的是排它锁，阻塞其它事务的写入和读取，若是其它的事务长时间不能写入就会直接报超时，所以它的性能也是最差的，对于它来就没有什么并发性可言。
对于读提交和可重复读，他们俩的实现是兼顾解决数据问题，然后又要有一定的并发行，所以在实现上锁机制会比串行化优化很多，提高并发性，所以性能也会比较好。
他们俩的底层实现采用的是MVCC（多版本并发控制）方式进行实现。

共享锁是针对同一份数据，多个读操作可以同时进行，简单来说即读加锁，不能写并且可并行读；排他锁针对写操作，假如当前写操作没有完成，那么它会阻断其它的写锁和读锁，即写加锁，其它读写都阻塞 。
而行锁和表锁，是从锁的粒度上进行划分的，行锁锁定当前数据行，锁的粒度小，加锁慢，发生锁冲突的概率小，并发度高，行锁也是MyISAM和InnoDB的区别之一，InnoDB支持行锁并且支持事务 。
而表锁则锁的粒度大，加锁快，开销小，但是锁冲突的概率大，并发度低。

间隙锁则分为两种：Gap Locks和Next-Key Locks。Gap Locks会锁住两个索引之间的区间，比如select * from User where id>3 and id<5 for update，就会在区间（3，5）之间加上Gap Locks。
Next-Key Locks是Gap Locks+Record Locks形成闭区间锁select * from User where id>=3 and id=<5 for update，就会在区间[3,5]之间加上Next-Key Locks。
那Mysql中什么时候会加锁呢？
在数据库的增、删、改、查中，只有增、删、改才会加上排它锁，而只是查询并不会加锁，只能通过在select语句后显式加lock in share mode或者for update来加共享锁或者排它锁。


### 事务底层实现原理

MVCC（多版本并发控制）原理
在实现MVCC时用到了一致性视图，用于支持读提交和可重复读的实现。
在实现可重复读的隔离级别，只需要在事务开始的时候创建一致性视图，也叫做快照，之后的查询里都共用这个一致性视图，后续的事务对数据的更改是对当前事务是不可见的，这样就实现了可重复读。
而读提交，每一个语句执行前都会重新计算出一个新的视图，这个也是可重复读和读提交在MVCC实现层面上的区别。

快照（视图）在MVCC底层是怎么工作的吗？
在InnoDB 中每一个事务都有一个自己的事务id，并且是唯一的，递增的 。
对于Mysql中的每一个数据行都有可能存在多个版本，在每次事务更新数据的时候，都会生成一个新的数据版本，并且把自己的数据id赋值给当前版本的row trx_id。