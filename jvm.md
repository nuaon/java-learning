### 运行时数据（JVM）（内存结构）

#### 方法区（Method Area）只有一个 线程共享/非线程安全
* JDK1.7 PermSpace 永久代
* JDK1.8 MetaSpace 元空间

* 常量
* 静态变量
* 类信息
* 即时编译器编译后的代码

*方法区内存不足时会抛出OutOfMemoryError（OOM）*

*垃圾回收器对这块区域的回收主要是针对常量池和类的卸载*


#### 堆（Heap） 只有一个 线程共享/非线程安全

* 对象
* 数组

*堆内存不足时会抛出OutOfMemoryError（OOM）*
*该区域的对象大部分都是短时间都会死亡的，故垃圾回收器针对该部分主要采用标记整理算法了回收该区域*


#### Java虚拟机栈

* 一个线程的创建就是一个栈，每个方法被当前线程调用了，就代表一个栈帧

*栈深度不够用时会抛出StackOverflowError*


#### 本地方法栈
* 调用C语言



发生full GC的条件是：
（1）调用System.gc时，系统建议执行Full GC，但是不必然执行
（2）老年代空间不足
（3）方法去空间不足
（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小



对象存活判断
- 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题
- 可达性分析：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象



metaspace其实由两大部分组成

Klass Metaspace就是用来存klass的，klass是我们熟知的class文件在jvm里的运行时数据结构，不过有点要提的是我们看到的类似A.class其实是存在heap里的，是java.lang.Class的一个对象实例。这块内存是紧接着Heap的，和我们之前的perm一样，这块内存大小可通过-XX:CompressedClassSpaceSize参数来控制，这个参数前面提到了默认是1G，但是这块内存也可以没有，假如没有开启压缩指针就不会有这块内存，这种情况下klass都会存在NoKlass Metaspace里，另外如果我们把-Xmx设置大于32G的话，其实也是没有这块内存的，因为会这么大内存会关闭压缩指针开关。还有就是这块内存最多只会存在一块。

NoKlass Metaspace专门来存klass相关的其他的内容，比如method，constantPool等，这块内存是由多块内存组合起来的，所以可以认为是不连续的内存块组成的。这块内存是必须的，虽然叫做NoKlass Metaspace，但是也其实可以存klass的内容，上面已经提到了对应场景。

Klass Metaspace和NoKlass Mestaspace都是所有classloader共享的，所以类加载器们要分配内存，但是每个类加载器都有一个SpaceManager，来管理属于这个类加载的内存小块。如果Klass Metaspace用完了，那就会OOM了，不过一般情况下不会，NoKlass Mestaspace是由一块块内存慢慢组合起来的，在没有达到限制条件的情况下，会不断加长这条链，让它可以持续工作。

元空间的特点

* 充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。
* 每个加载器有专门的存储空间
* 只进行线性分配
* 不会单独回收某个类
* 省掉了GC扫描及压缩的时间
* 元空间里的对象的位置是固定的
* 如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉

元空间的内存分配模型

* 绝大多数的类元数据的空间都从本地内存中分配
* 用来描述类元数据的类(klasses)也被删除了
* 分元数据分配了多个虚拟内存空间
* 给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些
* 归还内存块，释放内存块列表
* 一旦元空间的数据被清空了，虚拟内存的空间会被回收掉
* 减少碎片的策略






判断对象是否存活算法
1.引用计数算法
早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。
优点:实现简单效率高，被广泛使用与如python何游戏脚本语言上。
缺点:难以解决循环引用的问题，就是假如两个对象互相引用已经不会再被其它其它引用，导致一直不会为0就无法进行回收。

2.可达性分析算法
目前主流的商用语言[如java、c#]采用的是可达性分析算法判断对象是否存活。这个算法有效解决了循环利用的弊端。
它的基本思路是通过一个称为“GC Roots”的对象为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的。



三大垃圾收集算法
1.标记/清除算法【最基础】
2.复制算法
3.标记/整理算法
jvm采用`分代收集算法`对不同区域采用不同的回收算法。


新生代采用复制算法
GC进行时，Eden区所有存活的对象都被复制到To Survivor区，而From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阈值(默认15是因为对象头中年龄战4bit，新生代每熬过一次垃圾回收，年龄+1)，则移到老年代，没有达到则复制到To Survivor。



老年代采用标记/清除算法或标记/整理算法

由于老年代存活率高，没有额外空间给他做担保，必须使用这两种算法。
